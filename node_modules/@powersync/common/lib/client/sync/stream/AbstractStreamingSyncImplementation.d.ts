/// <reference types="node" />
import { ILogger } from 'js-logger';
import { StreamingSyncLine, StreamingSyncRequest } from './streaming-sync-types';
import { AbstractRemote } from './AbstractRemote';
import { BucketStorageAdapter } from '../bucket/BucketStorageAdapter';
import { SyncStatus, SyncStatusOptions } from '../../../db/crud/SyncStatus';
import { BaseObserver, BaseListener, Disposable } from '../../../utils/BaseObserver';
export declare enum LockType {
    CRUD = "crud",
    SYNC = "sync"
}
/**
 * Abstract Lock to be implemented by various JS environments
 */
export interface LockOptions<T> {
    callback: () => Promise<T>;
    type: LockType;
    signal?: AbortSignal;
}
export interface AbstractStreamingSyncImplementationOptions {
    adapter: BucketStorageAdapter;
    uploadCrud: () => Promise<void>;
    crudUploadThrottleMs?: number;
    /**
     * An identifier for which PowerSync DB this sync implementation is
     * linked to. Most commonly DB name, but not restricted to DB name.
     */
    identifier?: string;
    logger?: ILogger;
    remote: AbstractRemote;
    retryDelayMs?: number;
}
export interface StreamingSyncImplementationListener extends BaseListener {
    /**
     * Triggered whenever a status update has been attempted to be made or
     * refreshed.
     */
    statusUpdated?: ((statusUpdate: SyncStatusOptions) => void) | undefined;
    /**
     * Triggers whenever the status' members have changed in value
     */
    statusChanged?: ((status: SyncStatus) => void) | undefined;
}
export interface StreamingSyncImplementation extends BaseObserver<StreamingSyncImplementationListener>, Disposable {
    /**
     * Connects to the sync service
     */
    connect(): Promise<void>;
    /**
     * Disconnects from the sync services.
     * @throws if not connected or if abort is not controlled internally
     */
    disconnect(): Promise<void>;
    getWriteCheckpoint: () => Promise<string>;
    hasCompletedSync: () => Promise<boolean>;
    isConnected: boolean;
    lastSyncedAt?: Date;
    syncStatus: SyncStatus;
    triggerCrudUpload: () => void;
    waitForReady(): Promise<void>;
    waitForStatus(status: SyncStatusOptions): Promise<void>;
}
export declare const DEFAULT_CRUD_UPLOAD_THROTTLE_MS = 1000;
export declare const DEFAULT_STREAMING_SYNC_OPTIONS: {
    retryDelayMs: number;
    logger: ILogger;
    crudUploadThrottleMs: number;
};
export declare abstract class AbstractStreamingSyncImplementation extends BaseObserver<StreamingSyncImplementationListener> implements StreamingSyncImplementation {
    protected _lastSyncedAt: Date | null;
    protected options: AbstractStreamingSyncImplementationOptions;
    protected abortController: AbortController | null;
    protected crudUpdateListener?: () => void;
    protected streamingSyncPromise?: Promise<void>;
    syncStatus: SyncStatus;
    triggerCrudUpload: () => void;
    constructor(options: AbstractStreamingSyncImplementationOptions);
    waitForReady(): Promise<void>;
    waitForStatus(status: SyncStatusOptions): Promise<void>;
    get lastSyncedAt(): Date | undefined;
    get isConnected(): boolean;
    protected get logger(): ILogger;
    dispose(): Promise<void>;
    abstract obtainLock<T>(lockOptions: LockOptions<T>): Promise<T>;
    hasCompletedSync(): Promise<boolean>;
    getWriteCheckpoint(): Promise<string>;
    protected _uploadAllCrud(): Promise<void>;
    protected uploadCrudBatch(): Promise<boolean>;
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    /**
     * @deprecated use [connect instead]
     */
    streamingSync(signal?: AbortSignal): Promise<void>;
    protected streamingSyncIteration(signal: AbortSignal, progress?: () => void): Promise<{
        retry?: boolean;
    }>;
    protected streamingSyncRequest(req: StreamingSyncRequest, signal?: AbortSignal): AsyncGenerator<StreamingSyncLine>;
    protected updateSyncStatus(options: SyncStatusOptions): void;
    private delayRetry;
}
